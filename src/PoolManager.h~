#ifndef _POOL_MANAGER_
#define _POOL_MANAGER_

#include <vector>
#include <iostream>
#include <functional>
#include <string>
#include "utils.h"
#include "Slot.h"
#include "MType.h"


using namespace cv;

/* Note, that this class is a singleton. */
class PoolManager
{
    private:
        enum STORED{ IMAGE,OBJECT};

	static vector<Slot<Mat>*> imagesPool;
	static vector<Slot<vloP>*> objectsPool;
		
	static int numImages;
	static int maxImages; 
	static int numObjects;
	static int maxObjects;

        static PoolManager* instance;
     
    	PoolManager(int ipm, int op)
	{
	   createImagePool(ipm);
	   createObjectsPool(op);
	}



    public:
        /**
         * Static method for accessing class instance.
         * Part of Singleton design pattern.
         *
         * @return ObjectPool instance.
         */
        static PoolManager* getInstance()
        {
            if (instance == 0)
            {
                instance = new PoolManager(100,80);				
            }
            return instance;
        }

	static PoolManager* getInstance(int imp,int op)
        {
            if (instance == 0)
            {
                instance = new PoolManager(imp,op);
				
            }
            return instance;
        }


	static void createImagePool(int pool_size)
	{
	   PoolManager::imagesPool.reserve(pool_size);
	   PoolManager::maxImages = pool_size;
	   PoolManager::numImages = 0;
	}

	static void createObjectsPool(int pool_size)
	{
	   PoolManager::objectsPool.reserve(pool_size);
	   PoolManager::maxObjects = pool_size;
	   PoolManager::numObjects = 0;	 
	}

	/************************************************************************************************/
     /**
         * Returns instance of Resource.
         * 
         * New resource will be created if all the resources
         * were used at the time of the request.
         *
         * @return Resource instance.
         */
	inline	void* getResource(const char* id,int type)
        {

			ut::Trace tr = ut::Trace("getResource",__FILE__);
			
			if(type==IMAGE)
			{
				    Slot<Mat> *tmp;
					if(imagesPool.empty())  // if empty allocate one place
					{
						tmp = new Slot<Mat>(); 
						tmp->setId(id);
						imagesPool.push_back(tmp);
						PoolManager::numImages++;
						return tmp;
					}
					else
					{
						for(int i=0;i<PoolManager::numImages;i++)
						{
							tmp = imagesPool[i];
							if(strcmp(tmp->getId(),id)==0) 
								return tmp;  // it�s already in my pool
						}
						tmp = new Slot<Mat>(); 
						tmp->setId(id);
						imagesPool.push_back(tmp); // if not, I must save...
						PoolManager::numImages++;
						return tmp;
					}
			}
			if(type==OBJECT)
			{
				    Slot<vloP> *tmp;
					if(objectsPool.empty())
					{
						tmp = new Slot<vloP>(); 
						objectsPool.push_back(tmp);
						tmp->setId(id);
						PoolManager::numObjects++;
						return tmp;
					}
					else
					{
						for( int i=0;i<PoolManager::numObjects;i++)
						{
							tmp =  objectsPool[i];
							if(strcmp(tmp->getId(),id)==0) return tmp;
						}
						tmp = new Slot<vloP>(); 
						objectsPool.push_back(tmp);
						tmp->setId(id);
						PoolManager::numObjects++;
						return tmp;
					}
			}

			return NULL;

        }

   

   

/****************************************************************************
 * cleanPool
 * ----------------------------
 *  
 *
 ***************************************************************************/

		// Removes all objects from the pool
		void cleanPools(){
			if(PoolManager::numImages>PoolManager::maxImages || PoolManager::numObjects>PoolManager::maxObjects )
		  {
			  
			  while (!imagesPool.empty())
				{
					Slot <Mat> *T =imagesPool.back();
					imagesPool.pop_back();
					delete T;
				}
			   while (!objectsPool.empty())
				{
					Slot <vloP> *T =objectsPool.back();
					objectsPool.pop_back();
					vloP *P = T->getValue();
					while(!P->empty())
					{
						P->pop_back();
					}
					delete T;
				}
			
			PoolManager::numImages = 0;
			PoolManager::numObjects =0;
			imagesPool.reserve(PoolManager::maxImages);
			objectsPool.reserve(PoolManager::maxObjects);
		  } 
		}



/****************************************************************************
 * Element exists
 * ----------------------------
 ***************************************************************************/
		bool containsImage(const char*im)
		{
		 
			for(int i=0;i<PoolManager::numImages;i++)
			{
				Slot<Mat>* tmp = imagesPool[i];
				if(strcmp(tmp->getId(),im)==0) 
								return true;  // it�s already in my pool
			}
		    return false;
		}



/****************************************************************************
 * GET IMAGE
 * ----------------------------
 *  
 *  *
 * The resource must be initialized back to
 * the default settings before someone else
 * attempts to use it.
 ***************************************************************************/
	inline	Mat* getImage(const char *input){
			Slot<Mat> *newslot;
		    newslot=(Slot<Mat>*)getResource(input,IMAGE);
		    return	newslot->getValue();
		
		}


/****************************************************************************
 * STORE IMAGE
 * ----------------------------
 *  
 *
 ***************************************************************************/
inline int storeImage(Mat &image,const char *output){
			Slot<Mat> *newslot;
			newslot= (Slot<Mat>*)getResource(output,IMAGE);
			newslot->setValue(image);	
			return 0;
		}

/****************************************************************************
 * GET LIST OF POINTS
 * ----------------------------
 *  
 *
 ***************************************************************************/
		inline	vloP* getlObj(const char *input){
			Slot<vloP> *newslot;
			newslot= (Slot<vloP>*)getResource(input,OBJECT);
			return	newslot->getValue();
		}


/****************************************************************************
 * STORE LIST of POINTS
 * ----------------------------
 *  
 *
 ***************************************************************************/
		inline int storelObj(vloP _vlop,const char *output){
			Slot<vloP> *newslot;
		    newslot= (Slot<vloP>*)getResource(output,OBJECT);
			newslot->setValue(_vlop);
			return 0;
		}



};



#endif

